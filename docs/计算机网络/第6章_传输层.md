---
date-created: 2022-01-02
---

[toc]

# 1. 传输层与传输层控制协议

```ad-note
title: 传输层 vs. 网络层

- 网络层: 主机之间的逻辑通信
    - 相当于邮政服务，负责信的寻路和传送
- 传输层: 进程之间的逻辑通信 
    - 依赖于网络层服务，并增强了网络层服务
    - 相当于取信人，将信放到用户手里
```

![[计算机网络/src/Pasted image 20220102194104.png]]

## 1.1. 传输层的基本功能

==屏蔽==网络层的不同，==基于==网络层提供的服务，向应用层的不同进程提供==不同类型的服务==。

- 可靠，按序交付 (TCP)
    - 拥塞控制
    - 流量控制
    - 连接建立
- 不可靠的，无序的交付服务 (UDP)
    - 简单扩展了IP尽力而为的服务
- 其它服务:
    - 时延保证
    - 带宽保证
    - ……

## 1.2. 传输层协议需要解决的问题

### 1.2.1. 网络环境中进程的标识

为了提供进程通信功能，TCP/IP 协议族提出了==端口（port）==的概念，用于标识进程

- IP 地址选择主机
- 端口号选择进程

#### 端口号的分配

- 全局分配
- 本地分配

#### 端口号类型

|类型|范围|方式|
|:---:|:---:|:---:|
|熟知端口号|0~1023  | 由 IANA 采用全局分配方式分配给标准的 Internet 服务器进程  |
|注册端口号|1024~49151   | 以全局方式分配  |
|临时端口号|49152~65535   | 以本地分配方式由 TCP/UDP 软件临时分配  |

##### UDP 熟知端口号

|端口号|53|67/68|69|161/162|520|
|:---:|:---:|:---:|:---:|:---:|:---:|
|服务进程|DNS|DHCP|TFTP|SNMP|RIP|
|说明|域名服务|动态主机配置协议|简单文件传送协议|简单网络管理协议|路由信息协议|

##### TCP 熟知端口号

|端口号|20|21|23|25|80|179|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|服务进程|FTP 文件传输协议|FTP|TELNET|SMTP|HTTP|BGP|
|说明|（数据连接）|（控制连接）|网络虚拟终端协议|简单邮件|超文本传输|边界路由|

#### 进程

网络环境中一个进程的全网唯一标识需要一个==三元组==表示

|协议类型|IP 地址|端口号|
|:---:|:---:|:---:|
|TCP|121.5.21.2|80|

网络环境中分布式进程通信涉及两个不同主机的进程，因此一个完整的进程通信需要用一个==五元组==标识

|协议|本地 IP 地址|本地端口号|远程 IP 地址|远程端口号|
|:---:|:---:|:---:|:---:|:---:|
|TCP|202.1.2.5|30022|151.8.22.51|80|

#### 套接字

IP 地址 : 端口号

### 1.2.2. 多路复用与多路分用

#### 多路复用

发送方不同的应用进程都可以使用同一个传输层协议来传输数据

#### 多路分解

数据到达接收方时，接收方的传输层能够将其正确交付到目的应用进程

![[计算机网络/src/Pasted image 20220102200958.png]]

### 1.2.3. 传输的服务质量

- 可靠传输
- 流量控制
- 拥塞控制

## 1.2. 传输协议数据单元的基本概念

- 传输层对等实体之间需要进行虚通信。
- 传输层对等实体之间传输的报文称为传输协议数据单元 TPDU（Transport Protocol Unit）。
- TPDU 有效载荷是应用层的数据。 

![[计算机网络/src/Pasted image 20220102201102.png]]

## 1.3. Internet 的传输层协议

### 1.3.1. TCP

TCP 协议是一种==面向连接==的可靠的传输层协议，在通信始末需要建立/释放连接，传输报文段（字节流）

### 1.3.2. UDP

UDP协议是一种==无连接==的不可靠的传输层协议，传输数据报

# 2. 用户数据报协议 UDP

- UDP 协议的设计原则是协议简洁、运行高效快捷。
- UDP 协议被广泛地应用于==快速递交==比准确递交==更重要==的应用程序，如传输语音或影像。

## 2.1. 特点

### 2.1.1. 无连接 不可靠

- UDP 协议在传输报文之前==不需要==在通信双方之间==建立连接==，因此减少了协议开销与传输延迟。
- UDP 协议对报文除了提供一种可选的校验和之外，几乎==没有提供==其他的保证数据传输可靠性的措施。
- 如果 UDP 协议检测出在收到的报文出错，它就==丢弃==这个报文，既不确认，也不通知发送端和要求重传。
- UDP 协议提供的是“==尽力而为==”的传输服务。

### 2.1.2. 面向报文的传输协议

![[计算机网络/src/s6_01.svg]]

使用 UDP 协议时，应用进程必须选择合适长度的报文。

- 发送方 UDP 协议对应用层提交的报文，在添加 UDP 首部构成 ==UDP 报文==后就向下交付 IP 层。UDP 协议对应用层提交的报文，既不合并，也不拆分，而是保留这些报文的格式。
- 应用层交给 UDP 协议多长的报文，UDP 就照样发送，即==一次发送一个报文==。
- 接收方 UDP 协议对 IP 层提交上来的 UDP 报文，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。

### 2.1.3. 基于 UDP 的可靠传输

- 在应用层提供可靠性
- 应用层相关的错误恢复

## 2.2. UDP 报文格式

UDP 的报头固定为 8 字节，数据长度最大为 $65535-8=65527$ 字节

![[计算机网络/src/s6_02.svg]]

## 2.3. UDP 校验和的基本概念

### 2.3.1. 使用伪头部的目的

- 伪头部不是用户数据报的真正头部，只是==计算时临时加上去==的
- 伪报头只在计算时起作用，既不向低层传输，也不向高层传送
- 校验和：加上伪头部的所有报文，按照 16 位分割，相加后求反码

![[计算机网络/src/s6_03.svg]]

## 2.4. UDP 的适用范围

### 2.4.1. 原因

- 没有连接建立阶段 (连接建立会增加时延)
- 简单: 发送端和接收端都无需保持状态
- 分段头额外开销小
- 没有拥塞控制：可以想发多快就发多快

### 2.4.2. 范围

- 音频、视频播放应用
- 简短的交互式应用
- 多播与广播应用

UDP 协议是一种==适用于实时语音与视频传输==的传输层协议。

# 3. 传输控制协议 TCP

## 3.1. 特点

- 是一个可靠的、面向连接的协议，它允许一台计算机将数据按序、无差错地发往其他计算机。
- TCP 协议采用了==三次握手机制==、==确认/重发机制==、==滑动窗口机制（流量控制）==、拥塞控制。
- TCP 协议主要用于对数据传输可靠性、正确性要求较高的应用。

### 3.1.1. 提供面向连接的传输服务

- 应用进程使用 TCP 协议传输数据之前，必须在源进程端口与目的进程端口之间==建立一条 TCP 传输连接==。
- 由于 IP 协议不提供任何可靠性机制，TCP 协议的==可靠性需要由其自己解决==。

### 3.1.2. 面向字节流的传输

- TCP 协议将应用程序提交的数据看成是==一连串的、无结构的字节流==。
- TCP 不保证接收方应用程序收到的数据块和发送方应用程序发出的数据块具有对应的大小关系。只需保证==收到的字节流和发送的字节流完全一样==。
- 按序交付

![[计算机网络/src/Pasted image 20220102204717.png]]

### 3.1.3. 支持全双工通信

### 3.1.4. 支持同时建立多个并发的TCP连接

- TCP 协议支持一个服务器与多个客户端同时建立多条 TCP 连接。
- TCP 协议也支持一个客户端与多个服务器同时建立多条 TCP 连接。

### 3.1.5. 支持可靠的传输服务

- TCP 协议采用了==三次握手机制==、==确认/重发机制==、==滑动窗口机制（流量控制）==、拥塞控制。

## 3.2. TCP 报文格式

![[计算机网络/src/Pasted image 20220102204945.png]]

- 序号：指==本报文段==所发送的数据的==第一个字节的序号==
- 确认号：指出收到**对方的**==下一个 TCP 报文==的数据的==第一个字节的序号==。字节确认的优点是即使确认丢失也不一定导致发送方重传。 
- 头部长度：以 4 B 为单位，最多 $15\times 4=60$ B
- 6 个控制位
    - URG 紧急指针
    - ACK 确认位，为 1 时确认号字段才有效
    - PSH 推送位，一端的应用程序希望在键入一个命令后立即收到对方的响应
    - RST 复位位，出现严重差错时释放重连
    - SYN 同步位
        - `SYN==1 && ACK=0` : 连接请求报文
        - `SYN==1 && ACK==1` : 连接响应报文
    - FIN 终止位，用来释放一个连接，为 1 表示报文段的发送端数据已发送完毕
- 窗口字段：接收端使用该字段来通知发送端其接收缓冲区的大小
- 校验和：加伪首部，算校验和
- 紧急指针字段：与 URG 配合使用，指出本报文段紧急数据共多少字节
- 选项字段
    - 最大段长度 MSS：告诉对方自己缓存所能接受的报文段的==数据字段最大为 MSS 个字节==
    - 窗口扩大选项：3 B，其中有一个字节表示移位值 S。其作用是将 TCP 首部中的窗口位数增大到 (16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。
- 填充字段：为了使首部长度为 4 B 的整数倍

## 3.3. TCP 连接建立与释放

TCP 协议传输数据需经过三个阶段

- TCP 连接建立
- 报文传输
- TCP 连接释放

TCP 连接建立过程中要解决以下三个问题

- 要使每一方能够确知对方的存在。
- 要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）。
- 能够对传输层实体资源（如缓冲区大小）进行分配。 

### 3.3.1. TCP 连接的建立

三次握手机制

![[计算机网络/src/s6_04.svg]]

1. A 向 B 发送==连接请求报文==，SYN=1，选择第一个数据字节序号 seq=x
2. B 收到 TCP 连接请求报文，若同意则返回确认，确认号 ack=x+1，自己的序号 seq=y
3. A 收到 B 的确认报文，向 B 给出确认，确认号 ack=y+1；A 的 TCP 协议通知上层应用进程，与 B 的 TCP 连接已经建立

### 3.3.2. 报文传输

当客户进程与服务器进程之间的 TCP 连接建立后，双方的应用进程就可以使用这个连接进行==全双工的**字节流**==传输。

为了防止 TCP 连接处于长时间空闲，服务器的 TCP 协议为所建立的 TCP 连接设置了一个==保持计时器==（keep timer）。当服务器收到客户端的报文时，立即将保持计时器复位。如果保持计时器超时，服务器没有收到客户端的报文，则每隔 75 秒向客户端发送 10 个==探测报文==。如果没有得到客户端的响应，则假设客户端出现故障，终止 TCP 连接。

### 3.3.3. TCP 连接的释放

![[计算机网络/src/s6_05.svg]]

数据传输结束后，通信双方都可释放连接

1. A 先向 B 发送==连接释放报文==主动关闭 TCP 连接，FIN=1，序号 seq=u
2. B 发出确认，ack=u+1，序号 seq=v；TCP 通知高层；从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收
3. 若 B 已经没有要向 A 发送的数据，则其也要向 A 发出连接释放请求报文
4. A 收到 B 的连接释放报文后，发出确认

## 可靠传输的工作原理

自动重传请求协议 ARQ (Automatic Repeat reQuest)

### 停止等待协议

![[计算机网络/src/Pasted image 20220103104121.png]]

![[计算机网络/src/Pasted image 20220103104154.png]]

#### 信道利用率

![[计算机网络/src/Pasted image 20220103104425.png]]

$$
U={T_D\over T_D+\mathrm{RTT}+T_A}
$$

#### 特点

- 简单
- 信道利用率低

### 连续 ARQ 协议

- 流水线传输
    - 发送方可==连续发送==多个报文，不必每发完一个报文就停顿下来等待对方的确认。
    - 由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。

#### GBR 方式 (Go-back-N Repeat)

- 发送方连续发送多个报文，每个数据帧都有==编号==
- 接收方若发现某个报文出错，便向发送方发出 NAK，==NAK 中指明出错报文的编号==
- 接收方==丢弃==从==出错报文开始的所有数据帧==
- 发送方收到 NAK 帧后，从 NAK 帧中指明的数据帧开始重新发送数据

GBR 方式有==可能会将已正确传送到接收方的报文再重传一遍==，这显然是一种浪费。

![[计算机网络/src/Pasted image 20220103105016.png]]

#### 选择重发 (SR) 方式

当接收方发现某个报文出错后，其后接收到的正确的报文虽然不能立即递交给高层，但接收方仍可收下来，==存放在缓冲区中==，同时要求发送方==重新发送出错的那一个报文==。一旦正确收到重新传来的报文后，就可以和已存于缓冲区中的其余报文==一并按正确的顺序==递交给高层。

![[计算机网络/src/Pasted image 20220103105215.png]]

#### 问题引入

在使用连续 ARQ 发送协议时，实际上发送端==并不能无限制地==发送数据。发送端能够发送的报文的数量要==受到接收端的限制==。限制的因素如下

- 接收端的接收缓冲区的大小
- 接收端的接收速度
- 接收端需要等待重传的报文的个数

因此，连续 ARQ 发送协议中，应当对已发送出去但未被确认的报文的数量加以限制，即需要==流量控制==。

#### 滑动窗口机制

![[计算机网络/src/Pasted image 20220103105658.png]]

滑动窗口事实上是一张序号表，在发送端和接收端都保存了这样的序号表。

==发送窗口==用来对发送端进行流量控制，发送窗口的大小表示在还没有收到对方确认信息的情况下发送端最多可以发送多少个数据报文。

==接收窗口==是为了控制接收端可以接收哪些数据报文而不可以接收哪些报文,接收窗口的大小表示接收端==最多可以接收多少个数据报文==。在接收端只有当收到的数据报文的序号落入接收窗口内才允许将该数据报文收下，若接收到的数据报文落在接收窗口之外，则一律将其==丢弃==。

## 3.4. TCP 的可靠传输 确认/重传机制

### 3.4.1. 重传策略

若报文丢失或出错，发送端 TCP 协议需要重传丢失或出错的报文

#### 拉回重传方式

从出错或丢失的报文开始，重传之后的所有报文 (GBR)

#### 选择重传方式

仅需重传出错或丢失的报文 (SR)

### 3.4.2. 重传计时器

用来控制报文确认和等待重传的时间

- 当发送端 TCP 协议发送一个报文时，首先将该报文的副本放入重传队列（缓冲区），同时启动一个重传计时器，并开始倒计时。
- 当接收端 TCP 协议正确收到该 TCP 报文时，要给发送方返回一个确认
    - 若在重传计时器倒计时到 0 之前发送端 TCP 协议收到确认，表示报文传输成功，则从重传队列删除报文的副本。
    - 否则，表示报文传输失败。发送端从重传队列中提取报文副本进行重发。

TCP 协议支持==累积确认==的方式

- 累积确认不必对收到的报文逐个发送确认，而是对按序到达的最后一个报文发送确认，这样就表示：==到这个报文为止的所有报文都已正确收到了==。

## 3.5. TCP 流量控制

### 3.5.1. 滑动窗口机制

- 由接收方通过 TCP 报文头部的==通告窗口 AdvertisedWindow== 字段向发送方通告它的窗口大小
- 发送方在任意时刻没有确认的字节数不能超过通告窗口 AdvertisedWindow 的值
- 接收方根据分配的缓冲区的大小来为通告窗口 AdvertisedWindow 选择一个合适的值

- ==发送缓冲区==用来暂时存放：
    - 发送应用程序传送给发送方 TCP 准备发送的数据；
    - TCP 已发送出但尚未收到确认的数据。
- ==接收缓冲区==用来暂时存放：
    - 按序到达的、但尚未被接收应用程序读取的数据；
    - 不按序到达的数据。 

![[计算机网络/src/Pasted image 20220103120358.png]]

![[计算机网络/src/Pasted image 20220103120414.png]]

![[计算机网络/src/Pasted image 20220104101110.png]]

![[计算机网络/src/Pasted image 20220104101151.png]]

![[计算机网络/src/Pasted image 20220104101225.png]]

#### 流量控制机制

发送方 TCP 和接收方 TCP 的缓冲区大小是有限的，我们分别用 MaxSendBuffer 和 MaxRcvBuffer 表示

接收方的通告窗口

- AdvertisedWindow=MaxRcvBuffer - (LastByteRcvd - LastByteRead)
- 这个值就代表接收方 TCP 缓冲区==剩下的可用缓冲区==的大小 

发送方的发送窗口

- EffectiveWindow = AdvertisedWindow - (LastByteSend - LastByteAcked)
- 只有 EffectiveWindow 大于 0，发送方才能发送数据

### 3.5.2. 持续定时器

> 接收方的非零窗口通告丢失怎么办

- 只要 TCP 连接的一方收到对方的==零窗口通知==，就启动持续计时器。
- 若持续计时器设置的==时间到期==，就发送一个==零窗口探测报文段==（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。
- 若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。
- 若窗口不是零，则死锁的僵局就可以打破了。 

### 3.5.3. TCP 传输效率的考虑

#### TCP 报文段发送时机

1. TCP 维持一个变量，它等于最大报文段长度 MSS。只要==缓存中存放的数据达到 MSS 字节时==，就组装成一个 TCP 报文段发送出去
2. 由发送方的==应用进程指明要求==发送报文段，即 TCP 支持的推送 (push) 操作
3. 发送方的一个==计时器期限==到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去

#### 传输效率问题

> 发送应用程序产生数据很慢，或者接收应用程序接收数据很慢，或者两者都有时，网络传输的效率很低

##### 发送方 Nagle 算法

1. 发送端的 TCP 将它从发送应用程序收到的==第一块数据==发送出去，哪怕只有一个字节。
2. 在发送第一个报文段（即报文段 1）以后，发送端的 TCP 就在输出缓存中积累数据，并等待：或者==接收到一个确认报文==，或者数据已积累到可以装成一个==最大的报文段==。在这个时候，发送端的 TCP 就可以发送这个报文段。

优点：简单，它考虑到应用程序产生数据的速率，以及网络运输数据的速率。若应用程序比网络更快，则报文段就更大（最大报文段）。若应用程序比网络慢，则报文段就较小（小于最大报文段）。

##### 接收方

1. Clark 解决方法：只要==有数据到达就发送确认==，但宣布的窗口大小为零，直到或者缓存空间已能放入具有最大长度的报文段，或者缓存空间的一半已经空了
2. 延迟发送 ACK：接收端在确认收到的报文段之前一直等待，直到入缓存有足够的空间为止

## 3.6. TCP 的拥塞控制

端到端拥塞控制

### 3.6.1. 慢启动

cwnd 从 1 开始，逐渐乘 2 加倍式增长。

### 3.6.2. 拥塞避免

TCP 为每个连接维持一个新的状态变量，称为拥塞窗口 cwnd(CongestionWindow) 
- MaxWindow = MIN(cwnd, AdvertisedWindow)
- EffectiveWindow = MaxWindow - (LastByteSent - LastByteAcked)

![[计算机网络/src/Pasted image 20220104114908.png]]

- 当 TCP 连接进行初始化时，将拥塞窗口置为 1。图中的窗口单位不使用字节而使用报文段
- 在执行慢开始算法时，拥塞窗口 cwnd 的初始值为 1，发送第一个报文段 M0
- 发送端每收到一个对新报文段的确认，就把发送端的拥塞窗口加 1，因此拥塞窗口 cwnd 随着传输轮次按指数规律增长
- 当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（即当 cwnd = 16 时），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。
- 假定拥塞窗口的数值增长到 24 时，网络出现超时，表明网络拥塞了
- 更新后的 ssthresh 值变为 12（即发送窗口数值 24 的一半），拥塞窗口再重新设置为 1，并执行慢开始算法。 

### 3.6.3. 快速重传

![[计算机网络/src/Pasted image 20220104115955.png]]

### 3.6.4. 快速恢复

![[计算机网络/src/Pasted image 20220104120013.png]]


