# 第 5 章 自底向上的语法分析

## 5.1. 引言

- ==“移进-归约”法==基本思想
- 算法优先分析技术及优先函数
- LR 系列分析技术（LR(0), SLR(1), LR(1), LALR(1) 等）
- 二义性文法的应用
- 语法分析器的自动生成器 YACC

由于“移进-归约”法的基本思想，这些“归约”都是最左归约。因为输入串中的符号是从左向右逐个移进栈，这样最左边的可归约子串先被归约掉。

$\gtrdot$  $\lessdot$ $\doteq$  

## 5.2. 自底向上的语法分析面临的问题

设有文法 $G[S]$

$$
\begin{aligned}
S&\to cAd\\
A&\to a\mid Aa
\end{aligned}
$$

对于输入串 `#caad#`，采用自底向上分析技术，根据“移进-归约”思想，有以下序列

![[public/compile/compile050201.svg]]
其中，面临两个问题：

1. 如何寻找“可归约子串”？如何判定使用 $A\to a$ 还是 $A\to Aa$？
2. 可归约子串被归约到到一个非终结符？

可归约子串总是在栈顶产生，不会在栈内部产生。另外，在自底向上语法分析中，只有 4 个动作：移进、归约、接受、报错。

## 5.3. 算符优先分析技术

### 5.3.1. 算符优先关系的定义

很好理解，就例如乘法的优先级要高于加法。对于一个输入串 `#2*(3+4)#` 可以画出语法分析树，最终归约到一个结果。

![[public/compile/compile050301.svg]]

由图中，非终结符代表的是值，终结符都是运算符。因此在自底向上的算符优先分析中，==运算符是指文法中的所有终结符==，==运算数（运算对象）是所有非终结符==。归约的先后次序隐含了计算的先后次序。

算符优先分析技术对文法有一定的要求，如两个操作数之间至少有一个运算符。也就是说，若用非终结符表示操作数，则两个非终结符号之间至少要有一个或一个以上的运算符。

**定义 5.1** 若文法 $G$ 中不存在形式 $A\to\cdots UV\cdots$，其中 $A, U, V$ 均为非终结符，则称该文法是算符文法。通常，算符文法中也不包含 $A\to \varepsilon$，即不包含空规则。

由定义可知，算符文法产生的所有句型都满足：两个非终结符之间至少有一个或以上的终结符（运算符）

若文法 G 不是算符文法，则不能采用算符优先分析法。若是，则可以尝试对运算符进行优先关系分析。

在表达式 `#2+3*4+5*6#` 中只要通过相邻两个运算符之间的优先关系（如 `2+3*4` 中 `-` 和 `*` 相邻），就可以进行正确运算了。通过考察相邻运算符之间的优先关系，也许可以进行语法分析。由此引出“相邻”的概念

**定义 5.2** 若有 $ab$ 或 $aWb$，其中 $a,b\in V_\mathrm{T}$，$W\in V_\mathrm{N}$，则称运算符 $a,b$ 相邻

> 特别注意，运算符 $a$ 和 $b$ 相邻，要求 $a$ 在左边，$b$ 在右边，先后顺序不能颠倒，且 $a$ 与 $b$ 之间要么直接依靠在一起，要么最多有一个非终结符。显然，运算符 $a,b$ 相邻不一定有运算符 $b,a$ 相邻成立。

**定义 5.3** 设文法 G 是一个==算符文法==，对文法 G 中任何一对终结符 $a$ 和 $b$，定义：

1. $a\doteq b$ 当且仅当文法 G 中存在规则 $A\to \cdots ab\cdots$ 或 $A\to\cdots aRb \cdots$，其中 $a,b\in V_\mathrm{T};R\in V_\mathrm{N}$
2. $a \lessdot b$ 当且仅当文法 G 中存在规则 $A\to\cdots aR \cdots$ 并且 $R\overset{+}{\Rightarrow}b\cdots$ 或 $R\overset{+}{\Rightarrow}Qb\cdots$，其中 $a,b\in V_\mathrm{T};Q,R\in V_\mathrm{N}$
3. $a \gtrdot b$ 当且仅当文法 G 中存在规则 $A\to\cdots Rb \cdots$ 并且 $R\overset{+}{\Rightarrow}\cdots a$ 或 $R\overset{+}{\Rightarrow}\cdots aQ$，其中 $a,b\in V_\mathrm{T};Q,R\in V_\mathrm{N}$

> 书上的 $\doteq$ 符号好像点应该是夹在在等号两线中间，但是好像没找到这个符号，最像的只有 $\eqcirc$，$=\!\!\!\!\!\cdot$ 写出来又太丑

> 对于定义的理解：
> 首先，归约是指产生式右部归约为产生式左部
> 对于 1，产生式右部包含了 $a,b$，那么这两个算符必定==同时能够被归约==，即对应了算符的优先级相等
> 对于 2 和 3，$R$ 能够推导出算符 $b$，那么在归约过程中，==$b$ 应当先被归约，而 $aR$ 应当后被归约==，也就对应着，==先被归约的优先级更高，后被归约的优先级更低==。

$a,b$ 之间可能不存在优先关系，有可能是上述 3 种之一，也有可能是 3 种中的两种或多种。但对我们有用的是==不存在或存在一种==

**定义 5.4** 若一个算符文法 G 种任何一对终结符号 $a,b$ 之间最多存在上述中的一种，则称文法 G 是一个==算符优先文法==。

显然，若一对终结符号 $a,b$ 之间不存在优先关系，表明 $a,b$ 不可能相邻

> 注意：不要混淆==算符文法==和==算符优先文法==

为方便处理，我们约定：

- $\#\lessdot$ 任何终结符号
- 任何终结符号 $\gtrdot \#$
- $\#$ 与 $\#$ 之间不存在优先关系

对于句型 $AaBbCcDd$，有产生式规则 $U\to BbCcD$，则可以看作以下形式

![[public/compile/compile050302.svg]]

可归约子串特点：左边 $\lessdot$，中间 $\doteq$，右边 $\gtrdot$

而对于一般形式的句型，可归约子串的结构与其形式类似。

![[public/compile/compile050303.svg]]
算符优先分析法首先定义终结符之间的优先关系，然后通过该优先关系按图所示方式，寻找或确定可归约子串。由此，引出素短语的定义

**定义 5.5** 算符优先文法的句型中具有上图结构特征且至少含有一个终结符的子串称为该句型的一个素短语（质短语）

> 一个素短语不可能包含其他的素短语，素短语是归约的==最小单位==

> 算符文法不允许两个相邻非终结符或者只有单个非终结符在规则的右部

**例 5.3** 试分析下图终结符之间的优先关系

![[public/compile/compile050304.svg]]

- 有 $A\to CcdD$，故 $c\doteq d$
- $d$ 与 $a$ 相邻， $CcdD$ 先被归约，因此 $d \gtrdot a$；或由 $Z\to Aa\cdots,A \overset{+}{\Rightarrow} \cdots dD,d \gtrdot a$
- $a$ 与 $e$ 相邻，$eE$ 先被归约，因此 $a \lessdot e$

句型 $\#CcdDaeE$ 的素短语有两个 $CcdD$ 和 $eE$

**定义 5.6** 算符优先文法的一个句型中最左边的素短语称为最左素短语

### 5.3.2. 算符优先关系表的生成

**定义 5.7** 对文法中每一个非终结符 $P$，定义 

- $\text{FirstVT} (P)=\{a\mid P \overset{+}{\Rightarrow} a\cdots \text{ or } P \overset{+}{\Rightarrow} Qa \cdots, a\in V_\mathrm{T}, Q\in V_\mathrm{N}\}$
- $\text{LastVT} (P)=\{a\mid P \overset{+}{\Rightarrow}\cdots a \text{ or } P \overset{+}{\Rightarrow}\cdots aQ, a\in V_\mathrm{T}, Q\in V_\mathrm{N}\}$

基于这两个集合，可以给出如下表述 $\lessdot, \gtrdot, \doteq$ 的等价定义

**定义 5.8** 设文法 G 是一个算符文法，对文法 G 中任何一对终结符 $a,b$，定义

1. $a\doteq b$ 当且仅当文法 G 中存在规则 $A\to\cdots ab\cdots \text{ or }A\to \cdots aRb\cdots$，其中 $a,b\in V_\mathrm{T}, R\in V_\mathrm{N}$
2. $a\lessdot b$ 当且仅当文法 G 中存在规则 $A\to \cdots aR\cdots \text{ and } b\in \text{FirstVT} (R)$，其中 $a,b\in V_\mathrm{T}, R\in V_\mathrm{N}$
3. $a \gtrdot b$ 当且仅当文法 G 中存在规则 $A\to \cdots Rb\cdots \text{ and } a\in \text{LastVT} (R)$，其中 $a,b\in V_\mathrm{T}, R\in V_\mathrm{N}$

要找出一个句型中的最左素短语，需要知道任何一对终结符之间的优先关系。为此用二维表登记所有的终结符之间的优先关系。

| None | $a$       | $b$        |
| --- | --------- | ---------- |
| $a$ | $\gtrdot$ | $\lessdot$ |
| $b$ | $\gtrdot$ | $\gtrdot$  | 

#### 1. 求 $\text{FirstVT}(P)$ 的算法

1. 若有规则 $P\to a\cdots \text{ or }P\to Qa\cdots$，则 $a\in \text{FirstVT}(P)$
2. 若有规则 $P\to Q\cdots$，则 $\text{FirstVT}(Q)$ 全部加入 $\text{FirstVT}(P)$
3. 反复利用上述两条规则，直到所有的非终结符的 FirstVT 集不再增大为止

#### 2. 求 $\text{FirstVT}(P)$ 的算法

1. 若有 $P\to \cdots a \text{ or } P\to \cdots aQ$，则 $a\in \text{LastVT}(P)$
2. 若有 $P\to \cdots Q$，则 $\text{LastVT}(Q)$ 全部加入 $\text{LastVT}(P)$
3. 反复利用上述两条规则，直到所有的非终结符的 LastVT 集不再增大为止

以求 FirstVT 集为例，具体实现时，可以定义一个布尔数组 $\text{FirstVT}[P,a]$，$\text{FirstVT}(P,a)=true$ 表示 $a\in \text{FirstVT}(P)$ 

对 $\text{FirstVT}[P,a]$ 赋初值，再利用一个栈，将所有初始 $\text{FirstVT}[P,a]=true$ 的符号对 $(P,a)$ 入栈，然后对栈施加一个循环，用于完成 2 和 3 的任务

```typescript
while (stack.length > 0) {
    let q: Pair = stack.pop();  // [Q, a]
    for (let rule in rules.match("P→Q...").group()) {  // 考察所有 P→Q... 的规则
        if (FirstVT[P, a] === false) {
            FirstVT[P, a] = true;
            stack.push([P, a]);
        }
    }
}
```


