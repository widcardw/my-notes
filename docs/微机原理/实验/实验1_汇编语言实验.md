---
date created: 2021-12-01 22:58
---

# 实验一 汇编语言实验

## 1.1. 实验目的

1. 掌握不同进制数及编码相互转换的程序设计方法，加深对数制转换的理解。
2. 熟悉程序调试的方法。

## 1.2. 实验内容

1. 系统调用的输入/输出基本实验。
2. 将 ASCII 码表示的十进制数转换为二进制数。
3. 实现格雷码到 ASCII 码的转换。

## 1.3. 实验 1-1 系统调用的输入/输出基本实验

### 程序 1：在显示器上的输出窗口显示 A~Z 共 26 个大写英文字母

#### （1）流程图

![[微机原理/实验/src/Pasted image 20211102205303.png]]

#### （2）代码

```assembly
SSTACK SEGMENT STACK
    DW 64 DUP(?)        ; 初始化 64 个字的栈空间
SSTACK ENDS
CODE SEGMENT
    ASSUME CS:CODE      ; 声明代码段
START:MOV CX,001AH      ; CX=26
    MOV DL,41H          ; DL='A'
    MOV AL,DL           ; AL='A', 因为在 AH=01H 和 AH=08H 的功能调用默认将键盘读入放在 AL
A1: MOV AH,02H          ; AH=2
    INT 21H             ; 功能调用 INT 21H, AH=02H
    INC DL              ; DL++ 即 DL='B'
    PUSH CX             ; CX 入栈
    MOV CX,0FFFFH       ; CX=0FFFFH
A2: LOOP A2             ; 循环 FFFFH 次后继续向下做(延迟)
    POP CX              ; CX=26, 取回 CX
    DEC CX              ; CX=25
    JNZ A1              ; if CX!=0: goto A1
    MOV AX, 4C00H
    INT 21H             ; 程序终止
CODE ENDS
    END START
```

#### （3）程序结果

26 个字母依次出现在输出窗口，每输出一个字符会有一小段延迟，因为在代码中加入了**利用循环编写的延迟程序**。

![[微机原理/实验/src/Pasted image 20211228085946.png]]

### 程序 2 ：读键盘输入的字符串到 DS:DX 指定缓冲区中并以回车结束

#### （1）流程图

![[微机原理/实验/src/Pasted image 20211102205335.png]]

#### （2）程序代码

```c
DATA1 SEGMENT
    MES1 DB 'This is tangdu INT 21H !','$'
DATA1 ENDS
;----------------------------------------------------------------------------
DATA2 SEGMENT
    MES2 DB 0FFH DUP(?)
DATA2 ENDS
;----------------------------------------------------------------------------
SSTACK SEGMENT STACK
    DW 64 DUP(?)        ; 64 个字的栈空间
SSTACK ENDS
;----------------------------------------------------------------------------
CODE SEGMENT
    ASSUME CS:CODE
;----------------------------------------------------------------------------
START: MOV AH,08H       ; 功能调用
    INT 21H             ; 读键盘输入到 AL 中无回显
    MOV AH,01H          ; 功能调用
    INT 21H             ; 读键盘输入到 AL 中并回显
    CALL ENTERR         ; 显示回车换行
    MOV CX,04H          ; CX=4
    MOV DL,41H          ; DL='A'
AA: MOV AH,02H          ; 功能调用
    INT 21H             ; 写 DL 中的数据到显示屏
    INC DL              ; DL='B'
    LOOP AA             ; 将 DL 中的数据显示出来, 最终输出 'ABCD'
    CALL ENTERR
    MOV AX,DATA1
    MOV DS,AX           ; DS 指向 DATA1 的地址
    MOV DX,OFFSET MES1  ; DX 存入 MES1 的偏移量
    MOV AH,09H
    INT 21H             ; 显示数据段 DATA1 中的字符串
    CALL ENTERR
    MOV AX,DATA2        
    MOV DS,AX           ; DS 指向 DATA2 的地址
    MOV DX,OFFSET MES2  ; DX 存入 MES2 的偏移量
    MOV AH,0AH
    INT 21H             ; 读入字符串放到数据段 DATA2 中,以回车结束
    ADD DX,02H          
    MOV AH,09H
    INT 21H             ; 将数据段 DATA2 中的字符串显示出来
    MOV AX,4C00H
    INT 21H             ; 程序终止
ENTERR:
    MOV AH,02H
    MOV DL,0DH          ; CR
    INT 21H             ; 回车
    MOV AH,02H
    MOV DL,0AH          ; LF
    INT 21H             ; 换行
    RET                 ; CRLF Windows 端换行
;----------------------------------------------------------------------------
CODE ENDS
	END START
```

#### （3）程序结果

- 键盘输入两个字符，输出了第二个字符
- 输出字符 `ABCD`
- 输出 `This is tangdu INT 21H !`
- 输入一段字符串，按回车结束，输出刚刚输入的字符，后面跟上一些随机的字符（这些字符由 `MES2 DB 0FFH DUP(?)` 初始化，因此为未知字符）

## 1.4. 实验 1-2 将 ASCII 码表示的十进制数转换为二进制数。

### （1）流程图

![[微机原理/实验/src/Pasted image 20211102210746.png]]

### （2）程序代码

```c
DATAS SEGMENT
   NUM1  DB 31H,32H,33H,34H,35H ; 数据段 30h-39h 对应的 0-9 的 ASCII 码
   NUM3  DW 1 DUP(0)            ; 自定义的段中表示有一个字，初始化为0，
DATAS ENDS

STACKS SEGMENT STACK
    DW  32 DUP(?)               ; 此处输入堆栈段代码
STACKS ENDS

CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
START:
    MOV AX,DATAS
    MOV DS,AX                   ; DS 指向数据段 DATAS 的首地址
    MOV NUM3,000AH              ; NUM3=10
       
    MOV SI,OFFSET NUM1          ; SI 指针指向源数据段，源变址寄存器
    MOV CX,0005H                ; NUM1 的位数
   
    MOV DX,0000H
READ:                           ; DX 相当于累加器
	; C 语言等价形式
    ; for (i = 0; i < str.length(); i++) {
    ;     dx *= 10;
    ;     dx += str[i] - '0';
    ; }
    MOV AL,[SI]                 ; AL 放源串的值
    MOV AH,00H                  ; 清理 AH
    SUB AL,30H                  ; AL=AL-'0'
    MOV BX,AX                   ; BX 中放入当前的十进制数
    MOV AX,DX                   ; AX=0, 1, 12, 123, 1234
    MUL NUM3                    ; 乘法，8位默认放AL  AX <- 10 * AX
    ADD AX,BX                   ; AX=1, 12, 123, 1234, 12345
    MOV DX,AX                   ; DX=1, 12, 123, 1234, 12345
    INC SI                      ; SI 自增一个，处理下一个
    LOOP READ

    ; MOV AH,02H    ; 显示 DL 中数据
    ; INT 21H		; 显示为 9，因为寄存器 DX 的值为 3039H，39H 为 '9' 的 ASCII 码

    MOV AH,4CH
    INT 21H

CODES ENDS
    END START
```

### （3）测试结果

`DX` 寄存器中的内容为 `3039H`，即为 12345

![[微机原理/实验/src/Pasted image 20211228090048.png]]

## 1.5. 实验 1-3 实现格雷码到 ASCII 码的转换。

### （1）流程图

![[微机原理/实验/src/Pasted image 20211102211912.png]]

### （2）程序代码

```c
// C 语言算法
for (int i = 0; i < 8; i++) {
    bin_code <<= 1;
    bin_code ^= gray_code;
}
```

```c
DATAS SEGMENT
    INFO  DB 'the result of GR to ASCII is:','$'
    GR_CODE DB ?
    BIN_CODE DB ?
DATAS ENDS

CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
START:
    MOV AX,DATAS
    MOV DS,AX
    
    MOV DX,OFFSET INFO      ; 取字符串 INFO 的偏移地址
    MOV AH,09H    
    INT 21H                 ; 将 INFO 的内容显示出来
    CALL ENTERR
    
    MOV GR_CODE,1100B       ; 格雷码为 1100B
    MOV BIN_CODE,0
    MOV BL,00H
    MOV DL,00H
    MOV CX,8
    MOV AL,GR_CODE          ; AL=1100B=0CH
OP:
    SHL BL,1
    XOR BL,AL
    LOOP OP
	
    ADD BL,30H              ; BL='0'+BL
    MOV BIN_CODE,BL
    MOV DL,BIN_CODE
    
    MOV AH,02H
    INT 21H                 ; 显示，结果为 4
    MOV AH,4CH
    INT 21H

ENTERR:
       MOV AH,02H
       MOV DL,0DH
       INT 21H    ; 回车
       MOV AH,02H
       MOV DL,0AH
       INT 21H    ; 换行
       RET 
CODES ENDS
    END START
```

### （3）测试结果

格雷码 `1100B` 转换为二进制为 `0100B`，转换为 ASCII 码为 `34H`，输出结果为 `4`

![[微机原理/实验/src/Pasted image 20211228090113.png]]
