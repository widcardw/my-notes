---
date-created: 2022-01-07
---

# 5. 设备管理

## 0. 设备管理

### 功能

- 设备中断处理
- 缓冲区处理
- 设备分配和去配
- 设备驱动调度
- 实现虚拟设备

## 1. I/O 工作原理

### 1.1. I/O 系统

#### 1.1.1. 定义

I/O 设备及其接口线路、控制部件、通道和管理软件合称为 I/O 系统

![[public/os/s5_01.svg]]

#### 1.1.2. 设备分类

##### 按信息交换单位

- 字符设备：键盘
- 块设备：硬盘

##### 按存储功能

- 顺序存取：磁带
- 直接存取：磁盘

### 1.2. I/O 控制方式

#### 1.2.1. 轮询方式

[[微机原理/第7章_输入输出#2 2 查询传送方式]]

需要 CPU 执行轮询软件的代码，例如自制键盘

![[public/os/s5_02.svg]]

#### 1.2.2. 中断方式

[[微机原理/第7章_输入输出#2 3 中断传送方式]]

![[public/os/s5_03.svg]]

#### 1.2.3. DMA 方式

[[微机原理/第7章_输入输出#2 4 直接数据通道传送方式（DMA）]]

![[public/os/s5_04.svg]]

#### 1.2.4. 通道方式

![[public/os/s5_05.svg]]

### 1.3. 设备控制器

I/O 端口地址与主存地址编址方式 [[微机原理/第7章_输入输出#1 5 I O 端口的寻址方式]]

- 独立编址 Intel
- 统一编址

## 2. I/O 软件原理

### 2.1. 设计目标和原则

- 设备无关性
- 出错处理
- 同步/异步传输
- 缓冲技术

### 2.2. I/O 软件层次

#### 2.2.1. I/O 中断处理程序

位于操作系统的底层，是与硬件密切相关的软件，它与系统的其余部分尽可能少地发生关系。OS 需要管理所有的硬件。

![[操作系统/1-1_操作系统的概念#计算机系统的层次结构]]

#### 2.2.2. 设备驱动程序

设备驱动程序，包括与设备密切相关的所有代码，其任务是把用户提交的逻辑 I/O 请求转换为物理 I/O 操作的启动和执行。如设备名转化为端口地址，逻辑记录转化为物理记录，逻辑操作转换为物理操作等。三个功能

- 设备初始化
- 执行设备驱动例程
- 调用和执行中断处理程序

#### 2.2.3. 与设备无关的 I/O 软件

##### 设备命名和设备保护

对于操作系统而言，设备都被看作文件，它与磁盘文件一样，通过路径名来寻址。每个设备都具有文件名、inode、文件所有者、权限位等属性。设备不仅具有文件名，且支持与文件相关的所有系统调用，如 `open()` `close()` `read()` `write()` 以及 
`lseek()` 等。

设备保护需要检查用户是否有权访问所申请的设备。在多数大中型计算机系统中，用户进程对 I/O 设备的直接访问是绝对禁止的，I/O指令定义为==特权指令==，通过==系统调用==方式间接的供用户使用。

![[public/os/s5_11.svg]]

##### 提供与设备无关的块尺寸

当创建文件并向其输入数据时，此文件必须被分配新的磁盘块。为了完成这种分配工作，操作系统需要为每个磁盘都配置一张记录空闲块表或==位示图==。分配空闲块的算法是独立于设备的，可在高于设备驱动程序的层次处理。

Windows：逻辑块“簇”

##### 缓冲技术

通常在内核空间开辟缓冲区，数据在缓冲区中缓冲后，再在用户缓冲区和设备之间传输。

![[public/os/s5_11.svg]]

```ad-caution
Linux 中 `cout << "xxx" << ...` 可以向缓冲区插入字节流，在最后加上 `endl` 时才能加上==换行符==并==清空缓冲==，此时字节流才能输出到屏幕上。
```

##### 设备分配和状态追踪

当用户发出设备使用请求时，要求操作系统检查相应设备的使用状态，并根据其忙闲状况来决定接受或拒绝这一请求。

##### 错误处理和报告

错误应尽可能在接近硬件的地方加以处理。如果控制器发现错误，应设法纠正和加以解决。如果未能处理错误，再交给设备驱动程序。

在许多情况下错误恢复，可由低层软件透明的得到解决，而高层软件甚至不知道错误存在。

#### 2.2.4. 用户空间的 I/O 软件

##### 库函数

```text
       逻辑层面        |   物理层面
printf() ---> write() ---> int 0x80
```

##### SPOOLing 软件

SPOOLing 就是在内核外运行的系统 I/O 软件，它采用预输入、缓输出和井管理技术，是多道程序设计系统中==处理独占型设备==的一种方法，创建守护进程和特殊目录，解决独占型设备的空占问题。

## 3. 缓冲技术

为了解决 CPU 与设备之间速度不匹配的矛盾，及协调逻辑记录大小与物理记录大小不一致的问题，提高 CPU 和设备的并行性，减少 I/O 操作对 CPU 的中断次数，放宽对 CPU 中断响应时间的要求。

### 3.1. 单缓冲

每当应用进程发出 I/O 请求时，操作系统在内存的系统区中开设一个缓冲区。

```mermaid
graph LR
A[进程]-->B[buffer]-->C[设备]
```

```mermaid
graph RL
A[设备]-->B[buffer]-->C[进程]
```


### 3.2. 双缓冲

![[public/os/s5_12.svg]]

### 3.3. 多缓冲

略

## 4. 磁盘管理

### 4.1. 磁盘

磁盘是一类高速大容量旋转型存储设备，是一种直接存取存储设备又称随机存取存储设备，他的每条物理记录都有确定位置和唯一地址。

![[public/os/disk.jpg]]

#### 4.1.1. 基本要素

- 磁道（柱面） ==Cylinder== 从 0 编号
- 磁头 ==Header== 从 0 编号
- 扇区 ==Sector== 从 1 编号，每个扇区存储数据量一样（尽管由于半径大小的原因，外侧的扇区大，内侧的扇区小）

##### 扩展

###### 交叉码

由于磁盘的读写如果按照顺序逐一编号，性能可能会较差，即：如果目标地址在较远处，则需要等待磁盘旋转，才能得到目标数据。

交叉码规定了交叉因子：每两个连续逻辑扇区之间所间隔的物理扇区数。这样就使得磁盘编号间隔编排，能够在一定程度上提高搜索速度。

![[public/os/s5_13.svg]]

#### 4.1.2. 物理扇区与逻辑扇区

##### 物理扇区

由 C, H, S 决定，因此有 “0 道 0 头 1 扇区的说法”

##### 逻辑扇区 LS

从 0 开始编号，与物理扇区一一对应，存在换算公式，其中，$a, b, c$ 分别表示柱面号，磁头号和扇区号

$$
LS=a*H*S+b*S+c-1
$$

某磁盘有 80 个柱面，2 个磁头，每个柱面有 16 个磁道，下表为其对应关系

|  C  |  H  |  S  |  LS  |
|:---:|:---:|:---:|:----:|
|  0  |  0  |  1  |  0   |
|  0  |  0  |  2  |  1   |
| ... | ... | ... | ...  |
|  0  |  0  | 16  |  15  |
|  0  |  1  |  1  |  16  |
|  0  |  1  |  2  |  17  |
| ... | ... | ... | ...  |
|  0  |  1  | 16  |  31  |
|  1  |  0  |  1  |  32  |
| ... | ... | ... | ...  |
|  1  |  0  | 16  |  47  |
|  1  |  1  |  1  |  48  |
| ... | ... | ... | ...  |
|  1  |  1  | 16  |  63  |
|  2  |  0  |  1  |  64  |
| ... | ... | ... | ...  |
| 79  |  1  | 16  | 2559 |

### 4.2. FAT 文件系统

不考，暂时放着

### 4.3. 搜查定位

磁盘存在旋转延迟和寻道延迟。该部分穿插寻道时间的计算。

#### FCFS 先来先服务算法

找到距离自己最近的磁道进行移动。会导致在磁道之间反复横跳。

#### SSTF 最短查找时间算法

考虑 I/O 请求之间的区别，总是==先执行查找时间最短==的请求（找最近的）。此算法存在饥饿现象，随着靠近当前磁头位置读写请求的不断到来，使得到来时间早但距离当前磁头位置较远的 I/O 请求服务被无限期地推迟。

#### 电梯调度算法 EA

电梯上行时，逐个处理电梯所在位置上方的请求，而不管电梯下方的请求。电梯下行时，逐个处理电梯所在位置下方的请求，而不管电梯上方的请求。

#### 扫描算法 SCAN

与电梯调度算法稍有不同，区别在于：电梯处理过==请求层数最高==的就直接下行，而==不会再去顶层==。扫描算法会==持续的扫到顶层或底层==，无论顶层或底层有无请求。

#### 循环扫描算法

磁臂总是从 0 号柱面开始扫描到最大号柱面，然后直接回到 0 号柱面重复进行。

### 4.4. 虚拟设备

#### 4.4.1. 问题的提出

对于卡片机打印机之类的设备，采用静态分配不利于提高系统效率。

#### 4.4.2. SPOOLing 设计与实现


