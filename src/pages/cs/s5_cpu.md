---
title: 第 5 章 中央处理器
layout: ~/layouts/MainLayout.astro
---

> [!info] 内容
> - CPU 的功能和基本结构
> - 指令执行过程
> - 数据通路的功能和基本结构
> - 控制器的功能和工作原理
> - 异常和中断机制
> 	- 异常和中断的基本概念
> 	- 异常和中断的分类
> 	- 异常和中断的检测与响应
> - 指令流水线
> 	- 指令流水线的基本概念
> 	- 指令流水线的基本实现
> 	- 结构冒险、数据冒险、控制冒险的处理
> 	- 超标量和动态流水线的基本概念
> - 多处理器基本概念
> 	- SISD、SIMD、MIMD、向量处理器的基本概念
> 	- 硬件多线程的基本概念
> 	- 多核处理器的基本概念
> 	- 共享内存多处理器 SMP 的基本概念

## 5.1. CPU 的功能和基本结构

### 5.1.1. CPU 的功能

CPU 由运算器和控制器组成，控制器的功能是负责协调并控制计算机各比肩执行的指令序列，包括取指令、分析指令、执行指令；运算器的功能是对数据进行加工。

> [!tip] CPU 的具体功能
> - 指令控制。完成取指令、分析指令、执行指令的操作，即程序的顺序控制
> - 操作控制。一条指令的功能往往由若干操作信号的组合来实现。CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作
> - 时间控制。多个中操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号
> - 数据加工。对数据进行算术和逻辑运算
> - 中断处理。对计算机运行过程中出现的异常情况和特殊请求进行处理

### 5.1.2. CPU 的基本结构

![[public/jz/jzcpustructuretsfgh.png]]

#### 1. 运算器

运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理。运算器是计算机对数据进行加工和处理的中心，它主要由算术逻辑单元 ALU、暂存寄存器、累加寄存器 ACC、通用寄存器组、程序状态字寄存器 PSW、移位器、计数器 CT 等组成。

1. ALU 主要进行算术逻辑运算
2. 暂存寄存器，用于暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏其原有内容。对应用程序员透明
3. 累加寄存器，是一个通用寄存器，用于暂时存放 ALU 运算的结果信息，可以作为加法运算的一个输入端
4. 通用寄存器组，如 AX、BX、CX、DX、SP 等，用于存放操作数和各种地址信息等。SP 是堆栈指针，用于指示栈顶的地址。
5. 程序状态字寄存器，保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如 OF、SF、ZF、CF 等。PSW 中的这些位参与并决定为操作的形成
6. 移位器，对操作数或运算结果进行移位运算
7. 计数器，控制乘除运算的操作步数

#### 2. 控制器

在控制器都是控制下，运算器、存储器和输入输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机协调工作。控制器的基本功能是执行指令，每条指令的执行是由控制器发出的一组微操作实现的

1. 程序计数器 PC：用于指出下一条指令在主存中的存放地址。CPU 根据 PC 的内容去主存中取指令。因程序中指令通常是顺序执行的，所以 PC 有==自增==功能
2. 指令寄存器：用于保存当前正在执行的那条指令
3. 指令译码器：仅对操作码字段进行译码，向控制器提供特定的操作信号
4. 存储器地址寄存器：用于存放要访问的主存单元地址
5. 存储器数据寄存器：用于存放向主存写入的信息或从主存读出的信息
6. 时序系统：用于产生各种时序信号，他们都由同一时钟分频得到
7. 为操作信号发生器：根据 IR 的内容（指令）、PSW 的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种

控制器的工作原理是，根据指令操作码、指令的执行步骤（微命令顺序）和条件信号来形成当前计算机各部件要用到的控制信号。计算机整机各硬件系统在这些控制信号的控制下协同运行，产生预期的执行结果。

## 5.2. 指令执行过程

### 5.2.1. 指令周期

CPU 从主存中取出并执行一条指令的时间称为指令周期，不同指令的指令周期可能不同。指令周期通常用若干机器周期表示，一个机器周期又包含若干时钟周期（也称节拍或 $T$ 周期，它是 CPU 操作的最基本单位）。每个指令周期内的机器周期数可以不等。

![[public/jz/jzzhouqi.png]]

> - a 为定长机器周期，每个机器周期包含 4 个节拍
> - b 为不定长机器周期，每个机器周期包含的节拍数可以为 4 个，也可以为 3 个

对于无条件转移 JMP X，在执行时不需要访问主存，只包含取指阶段（包括取指和分析）和执行阶段，所以其指令周期仅包含取指周期和执行周期。

对于间接寻址的指令，为了取操作数，需要先访问一次主存，取出有效地址，然后访问主存，取出操作数，所以还需包括间址周期。间址周期介于取指周期和执行周期之间。

![[public/jz/jzzhouqi2.png]]

当 CPU 采用中断方式实现主机和 I/O 设备的信息交换时，CPU 在每条指令执行结束前，都要发出中断查询信号，若有中断请求，则 CPU 进入中断响应阶段，又称中断周期。这样，一个完整的指令周期应包括==取指、间址、执行和中断== 4 个周期。

> ycf 版本教材为 ==取指、译码、运算、存储器写、寄存器写回== 这 5 个周期

上述 4 个总做周期都有 CPU 方寸操作，只是访存的目的不同。取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点。

为区别不同的工作周期，在 CPU 内设置 4 个标志触发器 FE, IND, EX, INT，分别对应 4 个周期，并以 "1" 状态表示有效。

### 5.2.2. 指令周期的数据流

数据流是根据指令要求依次访问的数据序列。在指令执行的不同阶段，要求依次访问的数据序列是不同的。而且对于不同的指令，它们的数据流往往也是不同的。

#### 1. 取指周期

根据 PC 中的内容，从主存中取出指令代码并存放在 IR 中，PC 自增。


![[public/jz/jzirzhouqi.png]]

#### 2. 间址周期

取擦偶综述有效地址。一次间址将指令中的地址码送到 MAR 并送至地址线，此后 CU 向存储器发出读命令，并获取有效地址并存至 MDR。

![[public/jz/jzidzhouqi.png]]

#### 3. 执行周期

执行周期的任务是取操作数，并根据 IR 中的指令字的操作码通过 ALU 操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。

#### 4. 中断指令

处理中断请求。假设程序断点存入堆栈中，并用 SP 指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据。

![[public/jz/jzintzhjouq.png]]

### 5.2.3. 指令执行方案

#### 1. 单指令周期

对所有指令都选用相同的执行时间来完成。每条指令都在固定的时钟周期内完成，指令之间串行执行，需要较长的周期来完成。

#### 2. 多指令周期

对不同类型的指令选用不同的执行步骤。指令之间串行执行，单可选用不同个数的时钟周期来完成不同指令的执行过程，指令需要几个周期就为其分配几个周期，不在要求所有指令占用相同的执行周期。

#### 3. 流水线方案

指令之间可以并行执行的方案，追求的目标是力争在每个时钟脉冲周期完成一条指令的执行过程（只在理想状态下达到这种效果）。这种方案通过在每个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。

## 5.3. 数据通路的功能和基本结构

### 5.3.1. 功能

数据在功能部件之间传送的路径称为数据通路，包括数据通路上流经的部件，如 ALU，通用寄存器，状态寄存器，异常和中断处理逻辑等。数据通路描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，这些都需要加以控制。

数据通路由控制部件控制，控制部件根据每条指令功能不同生成对数据通路的控制信号。数据通路的功能是实现 CPU 内部的运算器与据村器及寄存器之间的数据交换。

### 5.3.2. 基本结构

#### 1. CPU 内部单总线方式

将所有寄存器的输入端和输出端都连接到一条公共通路上，结构简单，但数据传输存在较多冲突的现象，性能较低。链接各部件的总线只有一条时，称为单总线结构；CPU 中有两条或多条总线时，构成爽总线结构或多总线结构。

#### 2. CPU 内部三总线方式

将所有寄存器的输入端和输出端都连接到多条公共通路上，，相比之下单总线中一个时钟内只允许传一个数据，因而指令执行效率低，因此采用多总线方式，同时在总线上传送不同的数据，提高效率

#### 3. 专用数据通路方式

根据指令执行过程中的数据和地址流动方向安排连接线路，避免使用共享的总线，性能较高，单硬件较大。

![[public/jz/jzcpupipeline.png]]

##### 寄存器之间的数据传送

寄存器之间的数据传送可通过 CPU 内部总线完成。上图中，某寄存器 AX 的输入输出分别由 AXin 和 AXout 控制。

以 PC 寄存器为例，把 PC 内容送至 MAR，实现传送操作的流程及控制信号为

- PC → Bus (PCout 有效，PC 内容送总线)
- Bus → MAR (MARin 有效，总线内容送 MAR)

##### 主存与 CPU 之间的数据传送

借助 CPU 内部总线完成。以 CPU 从主存读取指令为例说明数据在数据通路中的传送过程。实现传送操作的流程及控制信号为

- PC→ Bus → MAR (现行指令地址 → MAR)
- 1 → R (CU 发出读命令)
- MEM(MAR) → MDR
- MDR → Bus → IR (现行指令 → IR)

##### 执行算术或逻辑运算

由于 ALU 本身没有内部存储功能的组合电路，因此如要执行加法运算，相加的两这书必须在 ALU 的两个输入端同时有效。先将一个操作数经 CPU 内部总线送入暂存器 Y 保存，Y 的内容在 ALU 的左输入端始终有效，再将另一个操作数经总线直接送到 ALU 的右输入端。这样两个操作数都送入了 ALU，运算结果暂存在暂存器 Z 中。

- Ad(IR) → Bus → MARinMAR
- 1 → R
- MEM → 数据线 → MDR
- (ACC) + (Y) → Z
- Z → ACC

## 5.4. 控制器的功能和工作原理

### 5.4.1. 控制器的结构和功能

计算机硬件系统的五大功能部件通过数据总线、地址总线、控制总线连接在一起

![[public/jz/jzwudabujianlianxian.png]]

- 运算器部件通过数据总线与内存储器、输入设备、输出设备传送数据
- 输入设备和输出设备通过接口电路与总线相连接
- 内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传送数据
- 控制器部件从数据总线将诶手指令信息，从运算器部件接受指令转移地址，送出指令地址到地址总线，还要向系统中的部件提供它们运行所需要的控制信号

> [!info] 控制器是计算机系统的指挥中心，控制器的主要功能
> - 从主存中取出一条指令，并指出下一条指令在主存中的位置
> - 对指令进行译码或测试，产生相应的操作控制信号，一遍启动规定的动作
> - 指挥并控制 CPU、主存、输入、输出设备间的数据流动方向

### 5.4.2. 硬布线控制器

基本原理是根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号。它由==复杂的组合逻辑门电路和一些触发器==构成，又称组合逻辑控制器

#### 1. 硬布线控制单元图

指令操作码是决定控制单元发出不同操作命令（控制信号）的关键。为了简化控制单元 CU 的逻辑，将指令的操作码译码和节拍发生器从 CU 分离出来，便可得到简化的控制单元图。

![[public/jz/jzcustreg.png]]

CU 的输入信号来源：

- 经指令译码器产生的指令信息
- 时序系统产生的机器周期信号和节拍信号
- 来自执行单元的反馈信息，即标志

#### 2. 硬布线控制器的时序系统及微操作

- 时钟周期：用是中信号控制节拍发生器，可以产生节拍，每个节拍的宽度正好对应一个时钟周期。在每个节拍内机器可完成一个或几个需同时执行的操作
- 机器周期：可视为所有指令执行过程中的一个基准时间
- 指令周期：见 [[#5 2 1 指令周期]]
- 微操作命令分析

#### 3. CPU 控制方式

- 同步控制方式
	- 系统有一个统一的时钟，所有的控制信号均来自这个统一的时钟信号。通常以最长的微操作序列和最繁琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。
	- 控制电路简单
	- 运行速度慢
- 异步控制方式
	- 不存在基准时标信号，各部件按自身固有的速度工作，通过应答方式进行联络
- 联合控制方式
	- 介于同步、异步之间的一种折中
	- 这种方式对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制的办法

### 5.4.3. 微程序控制器

采用==存储逻辑实现==，把微操作信号==代码化==，使每条机器指令转化成一段微程序并存入一个专门的存储器中，微操作控制信号由微指令产生。

#### 1. 基本概念

设计思想是将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。

- 微指令与微操作
- 微指令与微周期
- 主存与控制存储器
- 程序与微程序

地址寄存器、微地址寄存器、指令寄存器、微指令寄存器。

#### 2. 微程序控制器组成和工作流程

##### 微程序控制器的基本组成

- 控制寄存器
- 微指令寄存器
- 微地址形成部件
- 微地址寄存器

![[public/jz/jzweichengxu.png]]

##### 微程序控制器的工作过程

- 执行取微指令公共操作
- 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入 CMAR
- 从 CM 中逐条取出对应的微指令并执行
- 执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第 1 步，以完成取下一条机器指令的公共操作

##### 微程序和机器指令

通常，一条机器指令对应一个微程序。由于任何一条机器指令的取指令操作都相同，因此可将取指令操作的微命令统一编成一个微程序。

此外，也可编出对应间址周期的微程序和中断周期的微程序。

#### 3. 微程序的编码方式

又称微指令的控制方式，指如何对微指令的控制字段进行编码，以形成控制信号。目标是在保证速度的情况下，尽量缩短指令字长。

- 直接编码方式
	- 无须译码，简单、直观，执行速度快，并行性好
	- 微指令字长过长
- 字段直接编码方式
	- 将微指令的微命令字段分成若干小段，把互斥性微命令组合在同一字段中
	- 缩短微指令字长，单比直接编码慢
- 字段间接编码方式

![[public/jz/jzweizhilingzhijie.png]]

![[public/jz/jzziduanzhijie.png]]

#### 4. 微指令的地址形成方式

- 直接由微指令的下地址字段给出
- 根据机器指令的操作码形成

#### 5. 微指令格式

##### 水平型微指令

![[public/jz/jzhoriweizhiling.png]]

从编码方式上看，直接编码、字段直接编码、字段间接编码、混合编码都属于水平型微指令。

指令中的一位对应一个控制信号，一条水平型微指令定义并执行集中并行的基本操作。

##### 垂直型微指令

| μOP      | Rd       | Rs  |
|:--------:|:--------:|:---:|
| 微操作码 | 目的地址 | 源地址    |

采用类似机器指令操作码的方式，在微指令中设置微操作码字段。采用微操作码编译法，一条垂直型微指令只能定义并执行一种基本操作。

##### 混合型微指令

在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写；微程序不长，执行速度较快。

##### 水平和垂直型比较

|                | 水平                     | 垂直                 |
| -------------- | ------------------------ | -------------------- |
| 并行操作       | 能力强、效率高、灵活性强 | 较差                 |
| 执行一条时间   | 较短                     | 较长                 |
| 微指令和微程序 | 微指令字长，微程序短     | 微指令字短，微程序长 |
| 用户掌握难易度 | 难                       | 易                     |

## 5.5. 异常和中断机制

CPU 的数据通路中有相应的异常检测和响应逻辑，外设接口中有相应的中断请求和控制逻辑，操作系统中有相应的中断服务程序。这些中断硬件显露和中断服务程序有机结合，共同完成异常和中断的处理过程。

### 5.5.1. 异常和中断的基本概念

由 ==CPU 内部产生==的意外事件被称为==异常==，有些教材也称内中断。由来自 CPU 外部的设备向 CPU 发出的中断请求被称为==中断==，通常用于信息的输入和输出，有些教材中称为外中断。

> [!caution]
> - 异常是 CPU 执行一条指令时，由 CPU 在其内部检测到的、与正在执行的指令相关的同步事件
> - 中断是一种典型的由外部设备触发的、与当前正在执行的指令无关的异步事件

当 CPU 正在执行用户程序的第 $i$ 条指令时检测到一个异常事件，或者正在执行第 $i$ 条指令后发现一个中断请求信号，则 CPU 打断当前用户程序，然后转到相应的==异常==或==中断处理程序==去执行。

- 若异常或中断处理程序能够解决相应的问题，则在异常或中断处理程序的最后，CPU 通过执行异常或中断==返回指令==，回到被打断的用户程序的第 $i$ 或 $i+1$ 条指令继续执行
- 如果是不可恢复的致命错误，则终止用户程序

### 5.5.2. 异常和中断的分类

#### 1. 异常的分类

##### 故障 Fault

在引起谷场的指令启动后、执行结束前被检测到的异常事件。

- 指令译码出现非法操作码
- 取数据发生缺页、缺段
- 整数除法除数为 0

##### 自陷 Trap

是预先安排的一种异常事件，通常做法是：是现在程序中用一条特殊指令或通过某种方式设定特殊控制标志来人为设置一个陷阱，当执行到被设置了陷阱的指令时，CPU 在执行完自陷指令后，自动根据不同陷阱类型，进行相应的处理，然后返回到自陷指令的下一条指令执行。

在 x86 机器中，用于程序调试“断点设置”和单步跟踪的功能就是通过陷阱机制来实现的。

故障异常和自陷异常属于程序性异常（软件中断）

##### 终止 Abort

如果在执行指令的过程中发生了使计算机无法继续执行的硬件故障，如果控制器出错、存储器校验错等，那么程序将无法继续执行，只能终止，此时，调出中断服务程序来重启系统。

终止异常和外中断属于硬件中断

#### 2. 中断的分类

中断是指来自 CPU 外部、与 CPU 执行指令无关的时间引起的中断，包括 I/O 设备发出的 I/O 中断（键盘输入、打印机缺纸等），或发生某种特殊时间（用户按 Esc，定时器计数时间到）等。

外部 I/O 设备通过特定的中断请求信号线向 CPU 提出中断请求，CPU 每执行一条指令就检查中断请求信号线，如果检测到中断请求，则进入中断响应周期。

##### 可屏蔽中断

通过可屏蔽中断请求线 INTR 向 CPU 发出的中断请求。CPU 可以在中断控制器中设置相应的屏蔽字来选择性屏蔽它。

##### 不可屏蔽中断

通过专门的不可屏蔽中断请求线 NMI 向 CPU 发出中断请求，通常是非常禁忌的硬件故障，如电源掉电等。

> [!info] 中断和异常的两个重要的不同点
> - “缺页” 和 “溢出” 等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不组织任何指令的完成
> - 异常的检测由 CPU 自身完成，不必通过外部的某个信号通知 CPU。对于中断，CPU 必须通过中断请求线获取中断源的信息，才能知道哪个设备发生了何种中断

### 5.5.3. 异常和中断的响应过程

##### 关中断

在保存断点和程序状态期间，不能被新的中断打断，因此要禁止响应新的中断，即关中断。通常通过设置 “中断允许 IF” 触发器来实现。

##### 保存断点和程序状态

为了能在异常和中断处理后正确返回到被中断程序继续执行，必须将程序断点（返回地址）送到栈或特定寄存器中。通常保存在栈中，这时为了支持异常或中断的嵌套。

异常和中断处理后还要回到被中断的程序继续执行，被中断时的程序状态字寄存器 PSWR 的内容也需要保存在栈或特定寄存器中，在异常和中断返回时恢复到 PSWR 中。

##### 识别异常和中断并转到相应的处理程序

软件页硬件识别两种方式。异常通常用软件方式，中断两种都可以。

软件识别方式指 CPU设置一个异常状态寄存器，用于记录异常原因。OS 使用一个统一的异常或中断查询程序，按优先级顺序查询异常状态寄存器，以检测异常和中断类型，先查询到的先被处理，然后转到内核中相应的处理程序。

硬件识别方式又称向量中断，异常或中断处理程序的首地址称为中断向量，所有中断向量都存放在中断向量表中。每个异常或中断都被指定一个中断类型号。在中断向量表中，类型号和中断向量一一对应。

整个响应过程是不可被打断的。响应过程结束后，CPU 就从 PC 中取出中断服务程序的第一条指令开始执行，直至中断返回，这一部分任务是由 CPU 通过执行中断服务程序完成的，整个中断处理过程由软硬件协同完成。

## 5.6. 指令流水线

同一时刻有多条指令在 CPU 的不同功能部件中并发执行，提高功能部件的并行性和程序的执行效率。

### 5.6.1. 基本概念

- 时间上并行：将一个任务分解为几个不同的子阶段，每个阶段在不同的功能部件上并行执行，以便在同一时刻能够同时执行多个任务，进而提升系统性能
- 空间上并行：在一个处理机内设置多个执行相同任务的功能部件，并让这些功能部件并行工作，这样的处理机被称为超标量处理机

#### 1. 指令流水线的定义

一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成。如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线。

一条指令的执行过程分为 5 个阶段

- 取指 IF
- 译码/读寄存器 ID
- 执行/计算地址 EX
- 访存 MEM
- 写回 WB

![[public/jz/jzliushuixiantu.png]]

设计原则
- 指令流水段个数以最复杂指令所用的功能段个数为准
- 流水段的长度以最复杂的操作所花的时间为准

假设某条指令的 5 个阶段所花时间分别为

- 取指 200ps
- 译码 100ps
- 执行 150ps
- 访存 200ps
- 写回 100ps

执行指令的总时间为 750 ps。按流水线设计原则，每个流水段都为 200ps，单条执行比串行费时更长。假设程序有 $N$ 条指令，单周期处理机所用时间为 $N\times 750$ ps，而流水线所用时间为 $(N+4) \times 200$ ps。对于整个程序来说，执行效率得到了大幅度提高。

> [!tip] 为了利于实现指令流水线，指令集应具有如下特征
> - 指令长度应尽量一致，有利于简化取指令和指令译码操作
> - 指令格式应尽量规整，尽量保证源寄存器的位置相同，有利于在指令未知时就可取寄存器操作数
> - 采用 Load/Store 指令，其他指令都不能访问存储器，这样可把 Load/Store 指令的地址计算和运算指令的执行步骤规整在同一个周期中
> - 数据和指令在存储器中“对齐”存放，一个流水段即可取到数据

#### 2. 流水线的表示方法

![[public/jz/jzliushuixianshikong.png]]

在时刻 10T 时，流水线上有 6 条指令流出，若采用串行方式执行，在时刻 10T 只能完成两条指令。

只有大量连续任务不断输入流水线，才能充分发挥流水线的性能，而指令的执行正好是连续不断的，适合采用流水线技术。

### 5.6.2. 流水线的实现

```mermaid
graph LR
A["程序计数器"] --> B["取指<br>IF"] --> C["译码<br>ID"] --> D["执行<br>EX"] --> E["访存<br>MEM"] --> F["写回<br>WB"]
```

#### 1. 流水线的数据通路

![[public/jz/jzliushuixiantonglu.png]]

各种寄存器和数据存储器均采用统一时钟 CLK 进行同步，每来一个时钟，就会有一条新的指令进入流水线 IF 段；同时流水线寄存器会锁存前段加工处理完成的数据和控制信号，为下一段的功能部件提供数据输入。

#### 2. 流水线的控制信号

| 控制信号    | 位置 | 来源 | 功能                                                    |
| ----------- | ---- | ---- | ------------------------------------------------------- |
| BranchTaken | IF   | EX   | 分支跳转信号，由 EX 段的 Branch & equal 生成            |
| RegDst      | ID   | ID   | 写入目的寄存器选择，1 → rd，0 → rt                      |
| RegWrite    | ID   | WB   | 控制寄存器堆写操作，1 表示数据需要写回指定的寄存器      |
| AluSrc      | EX   | EX   | ALU 的第二输入选择控制，0 → rt，1 → 立即数              |
| AluOp       | EX   | EX   | 控制 ALU 进行不同运算，具体取值与位宽和 ALU 设计有关    |
| MemWrite    | MEM  | MEM  | 控制数据寄存器写操作，0 → 读，1 → 写                    |
| MemToReg    | WB   | WB   | 1 → 将存储器读出数据写回寄存器，0 → 将 ALU 运算结果写回 | 

每个流水寄存器中保存的信息包括

- 后面流水段需要用到的所有数据信息，包括 PC+4，指令，立即数，目的寄存器，ALU 运算结果，标志信息等，他们是前面阶段在数据通路中执行的结果
- 前面传递过来的后面各流水段要用到的所有控制信号

#### 3. 流水线的执行过程

某些指令在某些功能段没有任何实质性擦偶走，只是等待一个时钟周期。

##### 取指 IF

- 以 PC 值为地址，从指令寄存器取出第一条指令字
- PC ← PC + 4

指令字通过 RD 输出端送入 IF/ID 流水寄存器，PC+4 也送入流水寄存器

##### 译码/读寄存器 ID

- 由控制器根据 IF/ID 流水寄存器的指令字生成后续各段需要的控制信号
	- 如 lw 指令
		- 根据 rs，rt 取出值 RS，RT
		- 符号扩展单元将指令字中的 16 位数扩展为 32 位
		- 多路选择器根据指令字生成可能的写寄存器编号 WriteReg#
- 时钟到来时，这些数据和控制信号连通顺序指令地址 PC+4，锁存到 ID/EX 流水寄存器

##### 执行/计算地址 EX

功能由具体指令确定，不同指令经 ID 段译码后得到不同的控制信号。

- 如 lw 指令
	- 计算访存地址 ==RS + (ext)IMM== → EX/MEM 流水寄存器
- 其他指令可能还要计算分支地址，生成分支跳转信号 BranchTaken
- RT 的值可能会在 MEM 段作为写入数据使用，WriteData 送入 EX/MEM 中
- WriteReg# 直接传送给 EX/MEM

##### 访存 MEM

功能由具体指令确定

- lw 指令
	- 根据 EX/MEM 中锁存的访存地址，写入数据和内存读写控制信号 MemWrite 多存储器进行读写操作
- 访存地址、WriteReg#，数据存储器读出的数据都会送入 MEM/WB 流水寄存器

##### 写回 WB

功能由具体指令确定，将 MEM/WB 流水线寄存器中数据存储器读出的数据写回指定寄存器 WriteReg#.

### 5.6.3. 流水线的冒险与处理

#### 1. 结构冒险

多条指令同时争用同一资源而形成的冲突，也称资源冲突。解决办法：

- 前一指令访存时，使后一条指令（以及其后续指令）暂停一个时钟周期
- 单独设置数据存储器和指令存储器，取指令和取数分别在不同的存储器进行

#### 2. 数据冒险

下一条指令会用到当前指令计算出的结果

- 写后读
	- 当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据
- 读后写
	- 当前指令读出数据后，下一条指令才能写该寄存器
- 写后写
	- 当前指令写入寄存器后，下一条指令才能写该寄存器

解决方案

- 后续指令暂停几个时钟周期
- 设置相关专用通道，不等前一条指令把结果写回寄存器，下一条指令也不读寄存器，而是直接把 ALU 的计算结果作为自己的输入数据，开始计算过程，使本来需要暂停的操作变得可以继续执行，称为==数据旁路技术==
- 通过编译器对数据相关的指令编译优化方法，调整指令顺序解决数据相关

#### 3. 控制冒险

执行转移、调用、返回指令会改变 PC 值，会造成断流。解决方法：

- 对转移指令进行分支预测，尽早生成转移目标地址
	- 静态预测：总是预测条件不满足，即继续执行后续指令
	- 动态预测：根据程序执行的历史情况，进行动态预测调整，有较高的预测准确率
- 预取转移成功和不成功两个控制流方向上的目标地址
- 加快和提前形成条件码
- 提高转移方向的猜准率

### 5.6.4. 流水线的性能指标

#### 1. 流水线的吞吐率

指在单位时间内流水线所完成的任务数量，或输出结果的数量。吞吐率基本公式

$$
\text{TP}=\frac{n}{T_{k} }
$$

式中，$n$ 是任务数，$T_{k}$ 是处理完 $n$ 个任务的总时间。$k$ 为流水段的段数，$\Delta t$ 为时钟周期。在输入流水线中的任务连续的理想情况下，一条 $k$ 段流水线能在 $k+n-1$ 个时钟周期内完成 $n$ 个任务。得出流水线的吞吐率为

$$
\text{TP}=\frac{n}{(k+n-1)\Delta t}
$$

连续输入的任务数 $n\to \infty$ 时，得最大吞吐率为 $\text{TP}_{\max}=1/\Delta t$

#### 2. 流水线的加速比

完成同样一批任务，不使用流水线与使用流水线所用时间之比。基本公式为

$$
S = \frac{T_{0} }{T_{k} }
$$

将 $T_{0}=kn \Delta t$ 代入得

$$
S = \frac{ kn\Delta t}{(k+n-1)\Delta t} = \frac{kn}{k+n-1}
$$

连续输入任务 $n\to \infty$ 时，得最大加速比为 $S_{\max}=k$

### 5.6.5. 高级流水线技术

有两种增加指令级并行的策略

- 多发射技术：通过采用多个内部功能部件，使流水线功能段能同时处理多条指令，处理机一次可以发射多条值∞那个进入流水线执行
- 超流水线技术：通过增加流水线级数来使更多的指令同时在流水线中重叠执行

#### 1. 超标量流水线技术

每个时钟周期内可并发多条独立指令，以并行操作方式将多条指令编译并执行，为此需配置多个功能部件。

![[public/jz/jzchaobiaoliang.png]]

#### 2. 超长指令字技术

静态多发射技术，由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字，为此可能需要多个部件。

#### 3. 超流水线技术

流水段划分越多，时钟周期越短，指令吞吐率越高，超流水线是通过提高流水线主频的方式来提升流水线性能的。

流水线级数越多，用于流水线寄存器的开销越大。

## 5.7. 多处理器的基本概念

### 5.7.1. SISD SIMD MIMD 的基本概念

基于指令流的数量和数据流的数量，将计算机体系结构分为 SISD, SIMD, MISD, MIMD 四类。常规单处理器属于 SISD，常规的多处理器属于 MIMD

#### 1. 单指令单数据流 SISD 结构

传统的串行计算机结构，仅包含一个处理器和一个存储器，处理器在一段时间内仅执行一条指令，按指令流规定的顺序串行执行指令流中的若干条指令。

为了提高速度，有些 SISD 计算机采用流水线的方式，因此，SISD 处理器有时会设置多个功能部件，并且采用多模块交叉方式组织存储器。

#### 2. 但指令多数据流 SIMD 结构

一个指令流同时对多个数据流进行处理，一般称为数据级并行技术。这种结构的计算机通常由一个指令控制部件、多个处理单元组成。每个处理单元虽然执行的都是同一条指令，但是每个单元都有自己的地址寄存器，每个单元就都有不同的数据地址。不同处理单元执行的同一条指令所处理的数据是不同的。

#### 3. 多指令流单数据流 MISD 结构

同时执行多条指令，处理同一数据，实际上不存在这样的计算机。

#### 4. 多指令流多数据流 MIMD 结构

同时执行多条指令分别处理多个不同的数据，MIMD 分为多计算机系统和多处理器系统。

多计算机系统中每个计算机节点都有各自的私有存储器，并且具有独立的主存地址空间，不能通过访存指令来访问不同节点的私有存储器。

多处理器系统是共享存储多处理器 SMP 系统的简称，具有贡献昂的单一地址，通过存取指令来访问系统中的所有存储器，也称共享存储 MIMD

SIMD 和 MIMD 是两种并行计算模式，其中 SIMD 是一种数据级并行模式，而 MIMD 是一种并行程度更高的线程级并行或线程级以上并行计算模式。

### 5.7.2. 硬件多线程的基本概念

在传统 CPU 中，线程的切换包含一系列开销，频繁切换会极大影响系统的性能。为了减少线程切换过程的开销，诞生了硬件多线程。

在支持硬件多线程的 CPU 中，必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节。

#### 1. 细粒度多线程

多个线程之间轮流较差执行指令，多个线程之间的指令是不相关的，可以乱需并行执行。在这种方式下，处理器能在每个时钟周期切换线程。

#### 2. 粗粒度多线程

仅在一个线程出现了较大开销的阻塞时，才切换线程，如 Cache 缺失。在这种方式下，当发生流水线阻塞时，必须清除被阻塞的流水线，新线程的指令开始执行前需要重载流水线，因此，线程切换的开销比细粒度多线程大。

#### 3. 同时多线程

上述两种多线程技术的变体，在实现指令级并行的同时，实现线程级并行。它在同一个时钟周期中，发射多个不同线程中的多条指令执行。

![[public/jz/jzduoxianchengdeng.png]]

### 5.7.3. 多核处理器的基本概念

指将多个处理单元集成到单个 CPU 中，每个处理单元称为一个核。每个核可以有自己的 Cache，也可共享一个 Cache。所有核一般都是对称的，并且共享主存储器，因此多核属于共享存储的对称多处理器。

在多核计算机系统中，如要充分发挥硬件性能，必须采用多线程（或多进程）执行，使得每个核同一时刻都有线程运行。

### 5.7.4. 共享内存多处理器的基本概念

具有共享的但以物理地址空间的多处理器被称为共享内存多处理器 SMP。处理器通过存储器中的共享变量互相通信，所有处理器都能通过存取指令访问存储器的位置。

> 即使这些系统共享同一个物理地址空间，它们仍然可以在自己的虚拟地址空间中单独运行程序。

单一地址空间的多处理器有两种类型

- 统一存储访问多处理器
	- 每个处理器对所有存储单元的访问时间大致相同，访问时间与哪个处理器提出访存请求及访问哪个字无关
- 非统一存储访问多处理器
	- 访存要求比其他快，具体取决于哪个处理器提出了访问请求以及访问哪个字


