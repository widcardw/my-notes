---
title: 1. 操作系统基本概念
layout: ~/layouts/MainLayout.astro
---

## 1.1.1 操作系统的概念

### 计算机系统的层次结构

![[public/os/s1_01.svg]]

### 定义

操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地==组织调度==计算机的工作和资源的分配，以提供给用户和其他软件方便的==接口和环境==，它是计算机系统中最基本的==系统软件==。

### 功能和目标

#### 作为系统资源的管理者

> 进程是一个程序的执行过程。执行前需要将该程序放到内存中，才能被 CPU 处理。

- 提供的功能
	- 处理机管理（对应进程被处理机 CPU 处理）
		- 进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享资源
		- 进程管理：进程控制、进程同步、进程通信、死锁处理、处理机调度
	- 存储器管理（把程序相关数据放到内存）
		- 内存分配与回收、地址映射、内存保护与共享、内存扩充
	- 文件管理（逐层打开文件夹，找到程序存放的位置）
		- 文件存储空间的管理、目录管理、文件读写管理和保护
	- 设备管理（将摄像头等设备分配给进程）
		- 缓冲处理、设备分配、设备处理、虚拟设备
- 目标
	- 安全高效

#### 作为用户和计算机硬件之间的接口

- 提供的功能
	- 命令接口（允许用户==直接==使用）
		- 联机命令接口（用户说一句，系统做一句）适用于分时或实时系统接口
		- 脱机命令接口（用户说一堆，系统做一堆）适用于批处理系统
	- 程序接口
		- 允许用户通过程序==间接==使用
		- 由一组==系统调用==组成
	- GUI
- 目标
	- 方便用户使用

#### 作为最接近硬件的层次

- 功能
	- 实现对硬件机器的拓展

没有任何软件支持的计算机成为==裸机==。在裸机上安装的==操作系统==，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。

通常把覆盖了软件的机器成为扩充机器，又称之为==虚拟机==。

## 1.1.2 操作系统的四个特征

### 并发 Concurrence

指两个或多个事件在同一时间间隔内发生。这些事情宏观上是同时发生的，但==微观上是交替发生的==。

事实上，操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。

> [!caution]
> 并行：同一时刻同时发生，如：同时和甲乙两人约会。
> 并发：宏观上同时发生，但微观上交替发生

### 共享 Sharing

即资源共享，系统中的资源可供内存中多个并发执行的进程共同使用。

- 互斥共享方式
  - 一个时间段内允许一个进程访问该资源
  - 一段时间内只允许一个进程访问的资源称为==临界资源==
- 同时共享方式
  - 一个时间段内允许多个进程“同时”访问该资源
  - 这里的“同时”也是宏观上的，在微观上仍然是分时复用

> [!note] **并发性和共享性互为存在条件**
> 
> 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义。
> 如果失去共享性，则 QQ 和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发。

### 虚拟 Virtual

虚拟是指把一个物理上的实体变为若干个==逻辑上的==对应物。物理实体是实际存在的，而逻辑上对应物是用户感受到的。

操作系统中利用了多种虚拟技术来实现虚拟处理器、虚拟内存、虚拟外设等。

- 空分复用技术
  运用虚拟存储技术，实际只有 4 GB 的内存，在用户看来似乎远远大于 4 GB。
- 时分复用技术
  运用虚拟处理器技术，通过多道程序设计技术，采用让多道程序并发执行的方法，分时使用一个处理器，实际上只有一个单核 CPU，在用户看来似乎有 6 个 CPU 在同时为自己服务。

### 异步 Asynchronism

异步是指，在多道程序环境下，允许多个程序==并发==执行，但由于资源有限，进程的执行==不是一贯到底==的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。

## 1.1.3 操作系统的发展与分类

### 手工操作阶段

缺点：用户独占全机、人机速度矛盾、资源利用率低

### 单道批处理机

引入脱机输入输出技术（用磁带完成），并==监督程序==负责控制作业的输入、输出。

监督程序即为操作系统的雏形。

特点自动性、顺序性、单道性

优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。

缺点：内存中仅能有一道程序运行，必须串行运行。CPU 有大量时间在空闲等待 I/O 完成，资源利用率依然很低。

### 多道批处理机

磁带每次向内存中输入多道程序。

操作系统正式诞生，并引入了中断技术，由操作系统负责管理这些程序的运行，各程序并发执行。

优点：多道程序并发执行，共享计算机资源，资源利用率大幅提升，CPU 保持忙碌状态，系统吞吐量增大。

缺点：用户响应时间长，没有人机交互功能，用户必须等待处理完成。

### 分时操作系统

计算机==以时间片为单位轮流==为各个用户/作业服务，各个用户可通过终端与计算机进行交互。

优点：用户请求可以被即时响应，解决了人机交互的问题，允许多个用户同时使用一台计算机，用户操作相互独立。

缺点：不能优先处理一些紧急任务，对各个用户/作业是完全公平的。

### 实时操作系统

计算机系统接收到外部信号后及时处理，并且要在==严格的时限内处理完事件==。有及时性和可靠性。能优先处理紧急任务。

- 硬实时系统（必须在绝对严格的规定时间内完成）
- 软实时系统（允许个别的违反）

### 其他几种

网络操作系统

分布式操作系统

个人计算机操作系统

## 1.1.4 操作系统的运行机制和体系结构

### 运行机制

#### 指令

- 特权指令
	- 不允许用户直接使用的指令，如 I/O、置中断指令、存取用于保护内存的寄存器、送程序状态字到程序状态字寄存器的指令等。
- 非特权指令
	- 允许用户直接使用，不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，防止用户程序对系统造成破坏。

#### 处理器状态

- 用户态
	- 只能处理非特权指令
- 核心态
	- 能处理特权、非特权指令

#### 程序

- 内核程序
	- 系统的==管理者==，运行在核心态
- 应用程序
	- 运行在用户态

### 操作系统内核

内核时计算机上配置的底层软件，是操作系统最基本、最核心的部分。

![[public/os/2-1-08.png]]

原语特点：

- 处于操作系统最底层，是最接近硬件的部分
- 运行具有原子性，操作只能一气呵成
- 运行时间较短，调用频繁

定义原语的直接方法是==关中断==，让其所有动作不可分割地完成后再==开中断==。

### 操作系统的体系结构

- 大内核
  - 将操作系统的主要功能模块都作为系统内核，运行在核心态
  - 优点：高性能
  - 缺点：内核代码庞大，结构混乱，难以维护
- 微内核
  - 只把最基本的功能保留在内核
  - 优点：内核功能少，结构清晰，方便维护
  - 缺点：需要频繁地在核心态和用户态之间切换，性能低

## 1.1.5 中断和异常

### 中断机制的诞生

#### 早期计算机

各程序只能串行运行，效率低

#### 操作系统诞生

引入中断机制，实现了多道程序并发执行

本质：发生中断就意味着==需要操作系统的介入，开展管理工作==

### 中断的概念和作用

1. 当中断发生时，CPU 立即进入核心态
2. 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
3. 对于不同的中断信号，会进行不同的处理

发生了中断，就意味着需要 OS 介入，开展管理工作。由于 OS 的管理工作（如进程切换，分配 I/O 设备等）需要使用特权指令，因此 CPU 要从用户态转换为核心态。==中断==可以使 CPU 从==用户态切换为核心态，使 OS 获得计算机的控制权==。有了中断，才能实现多道程序并发执行。==中断是用户态切换为核心态的**唯一**途径。==

### 中断的分类

#### 内中断（异常、例外、陷入）

信号来源：CPU 内部，与当前执行的指令有关（非法操作码、地址越界、运算溢出、缺页等）。异常不能被屏蔽，一旦出现，就应立即处理。

- 自愿中断（指令中断、系统调用）
- 强迫中断
  - 硬件故障（如：缺页）
  - 软件中断（整数除 0）

#### 外中断（中断）

信号来源：CPU 外部，与当前执行的指令无关

- 外设请求（如：I/O 操作完成发出的中断信号）
- 人工干预（用户强行终止一个进程）

![[public/os/os_interruption.svg]]
### 外中断的处理过程

![[public/os/1-1-02.png]]

1. 执行完每个指令后，CPU 都要检查当前是否有中断信号
2. 如果检测到外部中断信号，则需要保护被中断进程的 CPU 环境
3. 根据中断信号类型转入相应的中断处理程序

## 1.1.6 系统调用

### 作用

应用程序通过系统调用请求操作系统的服务。系统中的==各种共享资源都由操作系统统一掌管==，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/O 操作、文件管理等），都必须通过==系统调用的方式向操作系统提出服务请求==，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。

### 功能分类

- 设备管理
- 文件管理
- 进程控制
- 进程通信
- 内存管理

系统调用的执行过程

![[public/os/os_system_call_proc.svg]]

### 系统调用与库函数的区别

![[public/os/1-1-03.png]]

| 层次     | 功能                                                  |
| ------ | --------------------------------------------------- |
| 普通应用程序 | 可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及。                |
| 编程语言   | 向上提供库函数。有时会将系统调用封装言成库函数，以隐藏系统调用的一些细节，使上层进行系统调用更加方便。 |
| 操作系统   | 向上提供系统调用                                            |
| 裸机     |                                                     |

> [!warning]
> 由用户态进入核心态，不仅需要切换状态，而且所用的堆栈也可能需要由用户态切换到系统堆栈，但这个系统堆栈也是属于该进程的。

### 系统调用背后的过程

![[public/os/1-1-04.png]]

传递系统调用参数 → 执行陷入指令（用户态）→ 执行系统调用相应服务程序（核心态）→ 返回用户程序

> [!note]
> 1. 陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，从而CPU进入核心态
> 2. 发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行
> 3. 陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令

## 1.2. 操作系统引导

操作系统是一种程序，以数据的形式存放在硬盘上，而硬盘通常分为多个分区，一台计算机中又有多个或多种外部存储设备。操作系统引导是指计算机利用 CPU 运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统，一环扣一环的完成上述过程。

常见操作系统引导过程

#### 1. 激活 CPU

激活的 CPU 读取 ROM 中的 boot 程序，将指令寄存器置为 BIOS （基本输入/输出系统）的第一条指令，即开始执行 BIOS 的指令。

#### 2. 硬件自检

启动 BIOS 后，先进行硬件自检，检查硬件是否出现故障。有故障，则主板发出不同含义的蜂鸣，启动中止；无故障，屏幕显示 CPU、内存、硬盘等信息。

#### 3. 加载带有操作系统的硬盘

BIOS 开始读取 Boot Sequence （通过 CMOS 里保存的启动程序，或者通过与用户交互方式），把控制权交给启动顺序排在第一位的存储设备，然后 CPU 将该存储设备引导扇区的内容加载到内存中。

#### 4. 加载主引导记录 MBR

硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现一个存储设备不是可引导硬盘，就检查下一个存储设备。如无其他启动设备，就会死机。主引导记录 MBR 的作用是告诉 CPU 去硬盘的哪一个主分区去找操作系统。

#### 5. 扫描硬盘分区表 并加载硬盘活动分区

MBR 包含硬盘分区，硬盘分区表以特定的标识符区分活动分区和非活动分区。主引导分区扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）。找到后，开始加载硬盘活动分区，将控制权交给活动分区。

#### 6. 加载分区引导记录 PBR

读取活动分区的第一个扇区，这个扇区称为分区引导记录 PBR，其作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）。

#### 7. 加载启动管理器

分区引导记录搜索活动分区中的启动管理器，加载启动管理。

#### 8. 加载操作系统

## 1.3. 虚拟机

### 基本概念

虚拟机是一台逻辑计算机，是指利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境。

### 虚拟化方法

#### 第一类虚拟机管理程序

从技术上讲，第一类虚拟机管理程序就像一个操作系统，因为它是唯一一个运行在最高特权级的程序。它在裸机上运行并且具备多道程序功能。虚拟机管理程序向上层提供若干台虚拟机，这些虚拟机是裸机硬件的精确复制品。由于每台虚拟机都与裸机相同，所以在不同的虚拟机上可以运行任何不同的操作系统。

虚拟机作为用户态一个进程运行，不允许执行敏感指令。虚拟机上的操作系统认为自己运行在内核态，实际上不是，而是运行在**虚拟内核态**。用户进程运行在用户态。

#### 第二类虚拟机管理程序 

依赖于 Windows, Linux 等操作系统分配和调度资源的程序，很像一个普通的进程。例如 VMware。

运行在两类虚拟机管理程序上的 OS 都被称为**客户操作系统**，对于第二类虚拟机管理程序，运行在底层硬件上的操作系统称为**宿主操作系统**。

